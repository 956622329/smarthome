// pages/quest/quest.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    quest: 'js面试题',
    answer: '答案',
    status: true,
    imgurl: [],
    htmlQuestion: [],
    jsQuestion: [
      ['JavaScript有哪些数据类型，它们的区别？',
        'JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。\n\n其中 Symbol 和 BigInt 是ES6 中新增的数据类型：\nSymbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。\nBigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。\n \n这些数据可以分为原始数据类型和引用数据类型：\n栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）\n堆：引用数据类型（对象、数组和函数）\n \n两种类型的区别在于存储位置的不同：\n原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n \n堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：\n在数据结构中，栈中数据的存取方式为先进后出。\n堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。\n \n在操作系统中，内存被分为栈区和堆区：\n栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 \n堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。'],
      ['数据类型检测的方式有哪些',
        ''],
      ['判断数组的方式有哪些',
        '通过Object.prototype.toString.call()做判断\n\nObject.prototype.toString.call(obj).slice(8,-1) === \'Array\';\n\n通过原型链做判断\n\nobj.__proto__ === Array.prototype;\n\n通过ES6的Array.isArray()做判断\n\nArray.isArray(obj);\n\n通过instanceof做判断\n\nobj instanceof Array\n\n通过Array.prototype.isPrototypeOf\n\nArray.prototype.isPrototypeOf(obj)'],
      ['null和undefined区别',
        '首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\n\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。\n \nundefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n \n当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。'],
      ['intanceof 操作符的实现原理及实现',
        'instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n\nfunction myInstanceof(left, right) {\n  // 获取对象的原型\n  let proto = Object.getPrototypeOf(left)\n  // 获取构造函数的 prototype 对象\n  let prototype = right.prototype; \n \n  // 判断构造函数的 prototype 对象是否在对象的原型链上\n  while (true) {\n    if (!proto) return false;\n    if (proto === prototype) return true;\n    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型\n    proto = Object.getPrototypeOf(proto);\n  }\n}'],
      ['为什么0.1+0.2 ! == 0.3，如何让其相等',
        ''],
      ['== 操作符的强制类型转换规则',
        '使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。\n\n使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。\n\n使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。'],
      ['Object.is() 与比较操作符 “`===`”、“`==`” 的区别',
        ''],
      ['let、const、var的区别',
        '（1）块级作用域：块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：\n\n内层变量可能覆盖外层变量\n用来计数的循环变量泄露为全局变量\n（2）变量提升：var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。\n（3）给全局添加属性：浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。\n（4）重复声明：var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。\n（5）暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。\n（6）初始值设置：在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。\n（7）指针指向：let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。\n区别	var	let	const\n是否有块级作用域	×	✔️	✔️\n是否存在变量提升	✔️	×	×\n是否添加全局属性	✔️	×	×\n能否重复声明变量	✔️	×	×\n是否存在暂时性死区	×	✔️	✔️\n是否必须设置初始值	×	×	✔️\n能否改变指针指向	✔️	✔️	×'],
      ['箭头函数与普通函数的区别',
        '（1）箭头函数比普通函数更加简洁\n如果没有参数，就直接写一个空括号即可\n如果只有一个参数，可以省去参数的括号\n如果有多个参数，用逗号分割\n如果函数体的返回值只有一句，可以省略大括号\n如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：\nxxxxxxxxxx\nlet fn = () => void doesNotReturn();\n（2）箭头函数没有自己的this\n箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。\n（3）箭头函数继承来的this指向永远不会改变\nxxxxxxxxxx\nvar id = \'GLOBAL\';\nvar obj = {\n  id: \'OBJ\',\n  a: function(){\n    console.log(this.id);\n  },\n  b: () => {\n    console.log(this.id);\n  }\n};\nobj.a();    // \'OBJ\'\nobj.b();    // \'GLOBAL\'\nnew obj.a()  // undefined\nnew obj.b()  // Uncaught TypeError: obj.b is not a constructor\n对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向\nxxxxxxxxxx\nvar id = \'Global\';\nlet fun1 = () => {\n    console.log(this.id)\n};\nfun1();                     // \'Global\'\nfun1.call({id: \'Obj\'});     // \'Global\'\nfun1.apply({id: \'Obj\'});    // \'Global\'\nfun1.bind({id: \'Obj\'})();   // \'Global\'\n（5）箭头函数不能作为构造函数使用\n构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n（6）箭头函数没有自己的arguments\n箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。\n（7）箭头函数没有prototype\n（8）箭头函数不能用作Generator函数，不能使用yeild关键字'],
      ['new操作符的实现原理',
        'new操作符的执行过程：\n（1）首先创建了一个新的空对象\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。'],
      ['数组有哪些原生方法',
        '数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\n数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\n数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\n数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\n数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\n数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\n数组归并方法 reduce() 和 reduceRight() 方法'],
      ['什么是 DOM 和 BOM',
        'DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。\n\nBOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。'],
      ['对类数组对象的理解，如何转化为数组',
        '一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。\n常见的类数组转换为数组的方法有这样几种：\n通过 call 调用数组的 slice 方法来实现转换\nArray.prototype.slice.call(arrayLike);\n通过 call 调用数组的 splice 方法来实现转换\nArray.prototype.splice.call(arrayLike, 0);\n通过 apply 调用数组的 concat 方法来实现转换\nArray.prototype.concat.apply([], arrayLike);\n通过 Array.from 方法来实现转换\nArray.from(arrayLike);'],
      ['对AJAX的理解，实现一个AJAX请求',
        'AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。\n\n创建AJAX请求的步骤：\n创建一个 XMLHttpRequest 对象。\n在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\n在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。\n当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。\nconst SERVER_URL = \"/server\";\nlet xhr = new XMLHttpRequest();\n// 创建 Http 请求\nxhr.open(\"GET\", url, true);\n// 设置状态监听函数\nxhr.onreadystatechange = function() {\n  if (this.readyState !== 4) return;\n  // 当请求成功时\n  if (this.status === 200) {\n    handle(this.response);\n  } else {\n    console.error(this.statusText);\n  }\n};\n// 设置请求失败时的监听函数\nxhr.onerror = function() {\n  console.error(this.statusText);\n};\n// 设置请求头信息\nxhr.responseType = \"json\";\nxhr.setRequestHeader(\"Accept\", \"application/json\");\n// 发送 Http 请求\nxhr.send(null);'],
      ['JavaScript为什么要进行变量提升，它导致了什么问题',
        '变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。\n\n造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。\n \n首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。\n在解析阶段，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n全局上下文：变量定义，函数声明\n函数上下文：变量定义，函数声明，this，arguments\n在执行阶段，就是按照代码的顺序依次执行。\n \n那为什么会进行变量提升呢？主要有以下两个原因：\n提高性能\n容错性更好\n \n（1）提高性能\n在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。\n \n在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。\n（2）容错性更好\n变量提升可以在一定程度上提高JS的容错性，看下面的代码：\nxxxxxxxxxx\na = 1;\nvar a;\nconsole.log(a);\n如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。\n \n虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。\n \n总结：\n解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间\n声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行\n \n变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：\nxxxxxxxxxx\nvar tmp = new Date();\nfunction fn(){\n    console.log(tmp);\n    if(false){\n        var tmp = \'hello world\';\n    }\n}\nfn();  // undefined\n在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。\nxxxxxxxxxx\nvar tmp = \'hello world\';\nfor (var i = 0; i < tmp.length; i++) {\n    console.log(tmp[i]);\n}\nconsole.log(i); // 11\n由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。'],
      ['对原型、原型链的理解',
        '在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。\n\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n \n特点：JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。',
        ['https://cdn.nlark.com/yuque/0/2021/png/1500604/1615475711487-c474af95-b5e0-4778-a90b-9484208d724d.png']
      ],
      ['原型链指向',
        'xxxxxxxxxx\np.__proto__  // Person.prototype\nPerson.prototype.__proto__  // Object.prototype\np.__proto__.__proto__ //Object.prototype\np.__proto__.constructor.prototype.__proto__ // Object.prototype\nPerson.prototype.constructor.prototype.__proto__ // Object.prototype\np1.__proto__.constructor // Person\nPerson.prototype.constructor  // Person\nxxxxxxxxxx\np.__proto__  // Person.prototype\nPerson.prototype.__proto__  // Object.prototype\np.__proto__.__proto__ //Object.prototype\np.__proto__.constructor.prototype.__proto__ // Object.prototype\nPerson.prototype.constructor.prototype.__proto__ // Object.prototype\np1.__proto__.constructor // Person\nPerson.prototype.constructor  // Person'],
      ['对闭包的理解',
        '闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。\n\n闭包有两个常用的用途；\n闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n \n比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。\nxxxxxxxxxx\nfunction A() {\n  let a = 1\n  window.B = function () {\n      console.log(a)\n  }\n}\nA()\nB() // 1\n在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题\nxxxxxxxxxx\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：\n第一种是使用闭包的方式\nxxxxxxxxxx\nfor (var i = 1; i <= 5; i++) {\n  ;(function(j) {\n    setTimeout(function timer() {\n      console.log(j)\n    }, j * 1000)\n  })(i)\n}\n在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。\n第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。\nxxxxxxxxxx\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(\n    function timer(j) {\n      console.log(j)\n    },\n    i * 1000,\n    i\n  )\n}\n第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\nxxxxxxxxxx\nfor (let i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}'],
      ['对作用域、作用域链的理解',
        '1）全局作用域和函数作用域\n（1）全局作用域\n最外层函数和最外层函数外面定义的变量拥有全局作用域\n所有未定义直接赋值的变量自动声明为全局作用域\n所有window对象的属性拥有全局作用域\n全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。\n（2）函数作用域\n函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到\n作用域是分层的，内层作用域可以访问外层作用域，反之不行\n2）块级作用域\n使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）\nlet和const声明的变量不会有变量提升，也不可以重复声明\n在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。\n \n作用域链：\n在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。\n \n作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。\n \n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n \n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。'],
      ['对执行上下文的理解',
        '1. 执行上下文类型\n（1）全局执行上下文\n任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。\n（2）函数执行上下文\n当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\n（3）**eval**函数执行上下文\n执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。\n2. 执行上下文栈\nJavaScript引擎使用执行上下文栈来管理执行上下文\n当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。\nxxxxxxxxxx\nlet a = \'Hello World!\';\nfunction first() {\n  console.log(\'Inside first function\');\n  second();\n  console.log(\'Again inside first function\');\n}\nfunction second() {\n  console.log(\'Inside second function\');\n}\nfirst();\n//执行顺序\n//先执行second(),在执行first()\n3. 创建执行上下文\n创建执行上下文有两个阶段：创建阶段和执行阶段\n1）创建阶段\n（1）this绑定\n在全局执行上下文中，this指向全局对象（window对象）\n在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined\n（2）创建词法环境组件\n词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。\n词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域\n（3）创建变量环境组件\n变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。\n2）执行阶段\n此阶段会完成对变量的分配，最后执行完代码。\n \n简单来说执行上下文就是指：\n在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n \n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n全局上下文：变量定义，函数声明\n函数上下文：变量定义，函数声明，this，arguments'],
      ['对this对象的理解',
        'this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。\n第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。\n第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。\n第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。\n \n这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。'],
      ['call() 和 apply() 的区别',
        '它们的作用一模一样，区别仅在于传入参数的形式的不同。\napply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。\ncall 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。'],
      ['实现call、apply 及 bind 函数',
        ''],
      ['对Promise的理解',
        'Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n \n（1）Promise的实例有三个状态:\nPending（进行中）\nResolved（已完成）\nRejected（已拒绝）\n \n当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。\n \n（2）Promise的实例有两个过程：\npending -> fulfilled : Resolved（已完成）\npending -> rejected：Rejected（已拒绝）\n \n注意：一旦从进行状态变成为其他状态就永远不能更改状态了。\n \nPromise的特点：\n对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”；\n一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。\n \nPromise的缺点：\n无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n \n总结：\nPromise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。\n \n状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。\n \n注意：在构造 Promise 的时候，构造函数内部的代码是立即执行的'],
      ['Promise的基本用法',
        '（1）创建Promise对象\nPromise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。\n \nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\nxxxxxxxxxx\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n一般情况下都会使用**new Promise()**来创建promise对象，但是也可以使用**promise.resolve**和 **promise.reject**这两个方法：\nPromise.resolve\nPromise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：\nxxxxxxxxxx\nPromise.resolve(11).then(function(value){\n  console.log(value); // 打印出11\n});\nresolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；\n \n创建promise对象可以使用new Promise的形式创建对象，也可以使用Promise.resolve(value)的形式创建promise对象；\nPromise.reject\nPromise.reject 也是new Promise的快捷形式，也创建一个promise对象。代码如下：\nxxxxxxxxxx\nPromise.reject(new Error(“我错了，请原谅俺！！”));\n就是下面的代码new Promise的简单形式：\nxxxxxxxxxx\nnew Promise(function(resolve,reject){\n   reject(new Error("我错了，请原谅俺！！"));\n});\n下面是使用resolve方法和reject方法：\nxxxxxxxxxx\nfunction testPromise(ready) {\n  return new Promise(function(resolve,reject){\n    if(ready) {\n      resolve("hello world");\n    }else {\n      reject("No thanks");\n    }\n  });\n};\n// 方法调用\ntestPromise(true).then(function(msg){\n  console.log(msg);\n},function(error){\n  console.log(error);\n});\n上面的代码的含义是给testPromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出 “hello world”, 如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印No thanks；\n（2）Promise方法\nPromise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。\nthen()\n当Promise执行的内容符合成功条件时，调用resolve函数，失败就调用reject函数。Promise创建完了，那该如何调用呢？\nxxxxxxxxxx\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\nthen方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。\nthen方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n \n当要写有顺序的异步事件时，需要串行时，可以这样写：\nxxxxxxxxxx\nlet promise = new Promise((resolve,reject)=>{\n    ajax(\'first\').success(function(res){\n        resolve(res);\n    })\n})\npromise.then(res=>{\n    return new Promise((resovle,reject)=>{\n        ajax(\'second\').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    return new Promise((resovle,reject)=>{\n        ajax(\'second\').success(function(res){\n            resolve(res)\n        })\n    })\n}).then(res=>{\n    \n})\n那当要写的事件没有顺序或者关系时，还如何写呢？可以使用all 方法来解决。\n2. catch()\nPromise对象除了有then方法，还有一个catch方法，该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。\nxxxxxxxxxx\np.then((data) => {\n     console.log(\'resolved\',data);\n},(err) => {\n     console.log(\'rejected\',err);\n     }\n); \np.then((data) => {\n    console.log(\'resolved\',data);\n}).catch((err) => {\n    console.log(\'rejected\',err);\n});\n3. all()\nall方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。\nxxxxxxxxxx\njavascript\nlet promise1 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(1);\n    },2000)\n});\nlet promise2 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(2);\n    },1000)\n});\nlet promise3 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(3);\n    },3000)\n});\nPromise.all([promise1,promise2,promise3]).then(res=>{\n    console.log(res);\n    //结果为：[1,2,3] \n})\n调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。\n（4）race()\nrace方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。\nxxxxxxxxxx\nlet promise1 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       reject(1);\n    },2000)\n});\nlet promise2 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(2);\n    },1000)\n});\nlet promise3 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n       resolve(3);\n    },3000)\n});\nPromise.race([promise1,promise2,promise3]).then(res=>{\n    console.log(res);\n    //结果：2\n},rej=>{\n    console.log(rej)};\n)\n那么race方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\nxxxxxxxxxx\nPromise.race([promise1,timeOutPromise(5000)]).then(res=>{})\n5. finally()\nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\nxxxxxxxxxx\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n \n下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。\nxxxxxxxxxx\nserver.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。finally本质上是then方法的特例：\nxxxxxxxxxx\npromise\n.finally(() => {\n  // 语句\n});\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。'],
      ['对async/await 的理解',
        'async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么： \nxxxxxxxxxx\nasync function testAsy(){\n   return \'hello world\';\n}\nlet result = testAsy(); \nconsole.log(result)\nimg\n所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。\n \nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样：\nxxxxxxxxxx\nasync function testAsy(){\n   return \'hello world\'\n}\nlet result = testAsy() \nconsole.log(result)\nresult.then(v=>{\n    console.log(v)   // hello world\n})\n那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。\n \n联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n \n注意：Promise.resolve(x) 可以看作是 new Promise(resolve => resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。',
        ['https://cdn.nlark.com/yuque/0/2020/png/1500604/1605099411873-d2eac25a-5d8c-4586-bc36-769bce79010e.png']
      ],
      ['async/await对比Promise的优势',
        '代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 \nPromise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅 \n错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余 \n调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。 '],
      ['对象创建的方式有哪些',
        '一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n \n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n \n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n \n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n \n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n \n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。'],
      ['对象继承的方式有哪些',
        '（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n \n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n \n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n \n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。\n \n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。'],
      ['浏览器的垃圾回收机制',
        '（1）垃圾回收的概念\n垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。\n \n回收机制：\nJavascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。\nJavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。\n不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。\n（2）垃圾回收的方式\n浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。\n1）标记清除\n标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。\n垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。\n2）引用计数\n另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。\n这种方法会引起循环引用的问题：例如：obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。\nxxxxxxxxxx\nfunction fun() {\n    let obj1 = {};\n    let obj2 = {};\n    obj1.a = obj2; // obj1 引用 obj2\n    obj2.a = obj1; // obj2 引用 obj1\n}\n这种情况下，就要手动释放变量占用的内存：\nxxxxxxxxxx\nobj1.a =  null\n obj2.a =  null\n（3）减少垃圾回收\n虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。\n对数组进行优化：在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。\n对**object**进行优化：对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。\n对函数进行优化：在循环中的函数表达式，如果可以复用，尽量放在函数的外面。'],
      ['深拷贝 浅拷贝',
        '浅拷贝（2）Object.assign方法 对象合并（3）直接用=赋值\n深拷贝（1）采用递归去拷贝所有层级属性（2） 通过JSON对象来实现深拷贝（3）通过jQuery的extend方法实现深拷贝（4）lodash函数库实现深拷贝（5）Reflect法（6）手动实现深拷贝（7）如果对象的value是基本类型的话，也可以用Object.assign来实现深拷贝，但是要把它赋值给一个空对象（8）用slice实现对数组的深拷贝（9）用concat实现对数组的深拷贝（10）直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。（11）使用扩展运算符实现深拷贝\n深拷贝：\nconcat实现对数组的深拷贝，用slice实现对数组的深拷贝\nnewdata=JSON.parse(JSON.stringify(oldArray)) 缺点：Array,Oject可以，funtion不行，json没办法序列化函数，会自动忽略undefined和symbol，无法处理循环引用\n采用递归去拷贝所有层级属性\n']
    ],
    cssQuestion: [
      ['CSS选择器及其优先级',
        '选择器	格式	优先级权重\nid 选择器	#id	100\n类选择器	#classname	10\n属性选择器	a[ref=“eee”]	10\n伪类选择器	li:last-child	10\n标签选择器	div	1\n伪元素选择器	li::after	1\n相邻兄弟选择器	h1+p	0\n子选择器	ul>li	0\n后代选择器	li a	0\n通配符选择器	*	0\n对于选择器的优先级：\n标签选择器、伪元素选择器：1\n类选择器、伪类选择器、属性选择器：10\nid 选择器：100\n内联样式：1000\n注意事项：\n!important 声明的样式的优先级最高；\n如果优先级相同，则最后出现的样式生效；\n继承得到的样式的优先级最低；\n通用选择器（*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；\n样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。'],
      ['display的属性值及其作用',
        '属性值	作用\nnone	元素不显示，并且会从文档流中移除。\nblock	块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\ninline	行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\ninline-block	默认宽度为内容宽度，可以设置宽高，同行显示。\nlist-item	像块类型元素一样显示，并添加样式列表标记。\ntable	此元素会作为块级表格来显示。\ninherit	规定应该从父元素继承 display 属性的值。'],
      ['display的block、inline和inline-block的区别',
        '（1）block：会独占一行，多个元素会另起一行，可以设置 width、height、margin 和 padding 属性；\n\n（2）inline：元素不会独占一行，设置 width、height 属性无效。但可以设置水平方向的 margin 和 padding 属性，不能设置垂直方向的 padding 和 margin；\n（3）inline-block：将对象设置为 inline 对象，但对象的内容作为 block 对象呈现，之后的内联对象会被排列在同一行内。\n对于行内元素和块级元素，其特点如下：\n（1）行内元素\n设置宽高无效；\n可以设置水平方向的 margin 和 padding 属性，不能设置垂直方向的 padding 和 margin；\n不会自动换行；\n（2）块级元素\n可以设置宽高；\n设置 margin 和 padding 都有效；\n可以自动换行；\n多个块状，默认排列从上到下。'],
      ['隐藏元素的方法有哪些',
        'display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。\nvisibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件。\nopacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。\nposition: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。\nz-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。\nclip/clip-path ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。\ntransform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。'],
      ['display:none 与 visibility:hidden 的区别',
        '这两个属性都是让元素隐藏，不可见。两者区别如下：\n\n（1）在渲染树中\ndisplay:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；\nvisibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。\n（2）是否是继承属性\ndisplay:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；\nvisibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；\n（3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；\n（4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。'
      ],
      ['对盒模型的理解',
        'CSS3 中的盒模型有以下两种：标准盒子模型、IE 盒子模型\n盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。\n标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同：\n标准盒模型的 width 和 height 属性的范围只包含了 content，\nIE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。\n可以通过修改元素的 box-sizing 属性来改变元素的盒模型：\nbox-sizing: content-box表示标准盒模型（默认值）\nbox-sizing: border-box表示 IE 盒模型（怪异盒模型）',
        ['https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png#align=left&display=inline&height=366&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=746&size=0&status=done&style=none&width=600',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png?x-oss-process=image%2Fresize%2Cw_746#align=left&display=inline&height=368&margin=%5Bobject%20Object%5D&originHeight=462&originWidth=791&size=0&status=done&style=none&width=630']
      ],
      ['两栏布局的实现',
        '一般两栏布局指的是左边一栏宽度固定，右边一栏宽度自适应，两栏布局的具体实现：\n利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。\n.outer {\n  height: 100px;\n}\n.left {\n  float: left;\n  width: 200px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  width: auto;\n  background: gold;\n}\n利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置 overflow: hidden; 这样右边就触发了 BFC，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n利用 flex 布局，将左边元素设置为固定宽度 200px，将右边的元素设置为 flex:1。\n.outer {\n  display: flex;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  flex: 1;\n  background: gold;\n}\n利用绝对定位，将父级元素设置为相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  position: absolute;\n  width: 200px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  margin-left: 200px;\n  background: gold;\n}\n利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  width: 200px;\n  background: tomato;\n}\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 200px;\n  background: gold;\n}'],
      ['三栏布局的实现',
        '三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，三栏布局的具体实现：\n利用绝对定位，左右两栏设置为绝对定位，中间设置对应方向大小的 margin 的值。\n.outer {\n  position: relative;\n  height: 100px;\n}\n.left {\n  position: absolute;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n  background: lightgreen;\n}\n利用 flex 布局，左右两栏设置固定大小，中间一栏设置为 flex:1。\n.outer {\n  display: flex;\n  height: 100px;\n}\n.left {\n  width: 100px;\n  background: tomato;\n}\n.right {\n  width: 100px;\n  background: gold;\n}\n.center {\n  flex: 1;\n  background: lightgreen;\n}\n利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的 margin 值，注意这种方式，中间一栏必须放到最后：\n.outer {\n  height: 100px;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  float: right;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n.center {\n  height: 100px;\n  margin-left: 100px;\n  margin-right: 200px;\n  background: lightgreen;\n}\n圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。\n.outer {\n  height: 100px;\n  padding-left: 100px;\n  padding-right: 200px;\n}\n.left {\n  position: relative;\n  left: -100px;\n  float: left;\n  margin-left: -100%;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  position: relative;\n  left: 200px;\n  float: right;\n  margin-left: -200px;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n.center {\n  float: left;\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。\n.outer {\n  height: 100px;\n}\n.left {\n  float: left;\n  margin-left: -100%;\n  width: 100px;\n  height: 100px;\n  background: tomato;\n}\n.right {\n  float: left;\n  margin-left: -200px;\n  width: 200px;\n  height: 100px;\n  background: gold;\n}\n.wrapper {\n  float: left;\n  width: 100%;\n  height: 100px;\n  background: lightgreen;\n}\n.center {\n  margin-left: 100px;\n  margin-right: 200px;\n  height: 100px;\n}'],
      ['水平重真居中的实现',
        '利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 translate 来调整元素的中心点到页面的中心。该方法需要考虑浏览器兼容问题。\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%,-50%);\n}\n利用绝对定位，设置四个方向的值都为 0，并将 margin 设置为 auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况：\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    margin: auto;\n}\n利用绝对定位，先将元素的左上角通过 top:50%和 left:50%定位到页面的中心，然后再通过 margin 负值来调整元素的中心点到页面的中心。该方法适用于盒子宽高已知的情况\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;     /* 自身 height 的一半 */\n    margin-left: -50px;    /* 自身 width 的一半 */\n}\n使用 flex 布局，通过 align-items:center 和 justify-content:center 设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要考虑兼容的问题，该方法在移动端用的较多：\n.parent {\n    display: flex;\n    justify-content:center;\n    align-items:center;\n}\n另外，如果父元素设置了flex布局，只需要给子元素加上margin:auto;就可以实现垂直居中布局\n.parent{\n    display:flex;\n}\n.child{\n    margin: auto;\n}\n这里蛮有意思的 如果不在弹性布局中 margin:auto;只能做到水平居中\n这其中的道理可以看这篇文章了解一下（具体就是与auto的定义有关）'],
      ['对Flex布局的理解及其使用场景',
        'Flex 是 FlexibleBox 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。行内元素也可以使用 Flex 布局。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。\n以下 6 个属性设置在容器上：\nflex-direction 属性决定主轴的方向（即项目的排列方向）。\nflex-wrap 属性定义，如果一条轴线排不下，如何换行。\nflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。\njustify-content 属性定义了项目在主轴上的对齐方式。\nalign-items 属性定义项目在交叉轴上如何对齐。\nalign-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n以下 6 个属性设置在项目上：\norder 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。\nflex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。\nflex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。\nflex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。\nflex 属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。\nalign-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。\n简单来说：\nflex 布局是 CSS3 新增的一种布局方式，可以通过将一个元素的 display 属性值设置为 flex 从而使它成为一个 flex 容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用 flex-direction 来指定主轴的方向。可以使用 justify-content 来指定元素在主轴上的排列方式，使用 align-items 来指定元素在交叉轴上的排列方式。还可以使用 flex-wrap 来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用 order 属性来指定项目的排列顺序，还可以使用 flex-grow 来指定当排列空间有剩余的时候，项目的放大比例，还可以使用 flex-shrink 来指定当排列空间不足时，项目的缩小比例。'],
      ['对BFC的理解，如何创建BFC',
        '先来看两个相关的概念：\nBox: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个 Box 就是我们所说的盒模型。\nFormatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。\n块格式化上下文（Block Formatting Context，BFC）是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。\n通俗来讲：BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。\n创建 BFC 的条件：\n根元素：body；\n元素设置浮动：float 除 none 以外的值；\n元素设置绝对定位：position (absolute、fixed)；\ndisplay 值为：inline-block、table-cell、table-caption、flex 等；\noverflow 值为：hidden、auto、scroll；\nBFC 的特点：\n垂直方向上，自上而下排列，和文档流的排列方式一致。\n在 BFC 中上下相邻的两个容器的 margin 会重叠\n计算 BFC 的高度时，需要计算浮动元素的高度\nBFC 区域不会与浮动的容器发生重叠\nBFC 是独立的容器，容器内部元素不会影响外部元素\n每个元素的左 margin 值和容器的左 border 相接触\nBFC 的作用：\n解决 margin 的重叠问题：由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个 BFC，就解决了 margin 重叠的问题。\n解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为 0。解决这个问题，只需要把父元素变成一个 BFC。常用的办法是给父元素设置overflow:hidden。\n创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。\n.left{\n     width: 100px;\n     height: 200px;\n     background: red;\n     float: left;\n }\n .right{\n     height: 300px;\n     background: blue;\n     overflow: hidden;\n }\n<div class="left"></div>\n<div class="right"></div>\n左侧设置float:left，右侧设置overflow: hidden。这样右边就触发了 BFC，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。'],
      ['为什么需要清除浮动?清除浮动的方式',
        '浮动的定义： 非 IE 浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。\n浮动的工作原理：\n浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）\n浮动元素碰到包含它的边框或者其他浮动元素的边框停留\n浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。\n浮动元素引起的问题？\n父元素的高度无法被撑开，影响与父元素同级的元素\n与浮动元素同级的非浮动元素会跟随其后\n若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构\n清除浮动的方式如下：\n给父级 div 定义height属性\n最后一个浮动元素之后添加一个空的 div 标签，并添加clear:both样式\n包含浮动元素的父级标签添加overflow:hidden或者overflow:auto\n使用 :after 伪元素。由于 IE6-7 不支持 :after，使用 zoom:1 触发 hasLayout**\n.clearfix:after{\n    content: "\\200B";\n    display: table;\n    height: 0;\n    clear: both;\n  }\n  .clearfix{\n    *zoom: 1;\n  }'],
      ['CSS3中有哪些新特性',
        '新增各种 CSS 选择器 （: not(.input)：所有 class 不是“input”的节点）\n圆角 （border-radius:8px）\n多列布局 （multi-column layout）\n阴影和反射 （Shadoweflect）\n文字特效 （text-shadow）\n文字渲染 （Text-decoration）\n线性渐变 （gradient）\n旋转 （transform）\n增加了旋转,缩放,定位,倾斜,动画,多背景'],
      ['单行、多行文本溢出隐藏',
        '单行文本溢出\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;      // 溢出用省略号显示\nwhite-space: nowrap;         // 规定段落中的文本不进行换行\n多行文本溢出\noverflow: hidden;            // 溢出隐藏\ntext-overflow: ellipsis;     // 溢出用省略号显示\ndisplay:-webkit-box;         // 作为弹性伸缩盒子模型显示。\n-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列\n-webkit-line-clamp:3;        // 显示的行数\n注意：由于上面的三个属性都是 CSS3 的属性，不是所有浏览器都可以兼容，所以要在前面加一个-webkit- 来兼容一部分浏览器。'],
      ['position的属性有哪些，区别是什么',
        'position 有以下属性值：\n属性值	概述\nabsolute	生成绝对定位的元素，相对于 static 定位以外的一个父元素进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。\nrelative	生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过 left、top、right、bottom 属性进行规定。\nfixed	生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。\nstatic	默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。\ninherit	规定从父元素继承 position 属性的值\n前面三者的定位方式如下：\nrelative：元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。\nfixed：元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。\n图2\nabsolute：元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了position:relative/absolute/fixed的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：\n图3图4',
        ['https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png#align=left&display=inline&height=105&margin=%5Bobject%20Object%5D&originHeight=105&originWidth=448&size=0&status=done&style=stroke&width=447',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&originHeight=135&originWidth=516&size=0&status=done&style=stroke&width=446',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png#align=left&display=inline&height=142&margin=%5Bobject%20Object%5D&originHeight=183&originWidth=576&size=0&status=done&style=stroke&width=446',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&originHeight=137&originWidth=516&size=0&status=done&style=stroke&width=446']
      ],
      ['实现一个三角形',
        'CSS 绘制三角形主要用到的是 border 属性，也就是边框。\n平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border 属性是右三角形组成的，下面看一个例子：\ndiv {\n    width: 0;\n    height: 0;\n    border: 100px solid;\n    border-color: orange blue red green;\n}\n将元素的长宽都设置为 0，显示出来的效果是这样的：\nimage1\n所以可以根据 border 这个特性来绘制三角形：\n（1）三角 1\ndiv {\n    width: 0;\n    height: 0;\n    border-top: 50px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\nimg2\n（2）三角 2\ndiv {\n    width: 0;\n    height: 0;\n    border-bottom: 50px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\nimg3\n（3）三角 3\ndiv {\n    width: 0;\n    height: 0;\n    border-left: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\nimg4\n（4）三角 4\ndiv {\n    width: 0;\n    height: 0;\n    border-right: 50px solid red;\n    border-top: 50px solid transparent;\n    border-bottom: 50px solid transparent;\n}\nimg5\n（5）三角 5\ndiv {\n    width: 0;\n    height: 0;\n    border-top: 100px solid red;\n    border-right: 100px solid transparent;\n}\nimg6\n还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。',
        [
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1012&size=0&status=done&style=stroke&width=600',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png?x-oss-process=image%2Fresize%2Cw_500#align=left&display=inline&height=132&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=738&size=0&status=done&style=stroke&width=600',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png?x-oss-process=image%2Fresize%2Cw_500#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&originHeight=140&originWidth=630&size=0&status=done&style=stroke&width=600',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png?x-oss-process=image%2Fresize%2Cw_500#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=646&size=0&status=done&style=stroke&width=600',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png?x-oss-process=image%2Fresize%2Cw_500#align=left&display=inline&height=191&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=690&size=0&status=done&style=stroke&width=600',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png?x-oss-process=image%2Fresize%2Cw_500#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&originHeight=218&originWidth=738&size=0&status=done&style=stroke&width=600'
        ]
      ],
      ['如何解决 1px 问题?',
        '1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：\nwindow.devicePixelRatio = 设备的物理像素 / CSS像素。\n打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 devicePixelRatio 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是 2：\nimage\n这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。\n解决**1px 问题的三种思路：**\n思路一：直接写 0.5px\n如果之前 1px 的样式这样写：\nborder:1px solid #333\n可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：\n<div id="container" data-device={{window.devicePixelRatio}}></div>\n然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为 2 的情况：\n#container[data-device="2"] {\n  border:0.5px solid #333\n}\n直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要 8 及以上的版本，安卓系统则直接不兼容。\n思路二：伪元素先放大后缩小\n这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。\n思路是先放大、后缩小：**在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的**宽和高都设置为目标元素的两倍，border 值设为 1px。**接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一**，间接地实现了 0.5px 的效果。\n代码如下：\n#container[data-device="2"] {\n    position: relative;\n}\n#container[data-device="2"]::after{\n      position:absolute;\n      top: 0;\n      left: 0;\n      width: 200%;\n      height: 200%;\n      content:"";\n      transform: scale(0.5);\n      transform-origin: left top;\n      box-sizing: border-box;\n      border: 1px solid #333;\n    }\n}\n思路三：viewport 缩放来解决\n这个思路就是对 meta 标签里几个关键属性下手：\n<meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">\n这里针对像素比为 2 的页面，把整个页面缩放为了原来的 1/2 大小。这样，本来占用 2 个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：\nconst scale = 1 / window.devicePixelRatio;\n// 这里 metaEl 指的是 meta 标签对应的 Dom\nmetaEl.setAttribute(\'content\', `width=device-width,user-scalable=no,initial-scale=${scale},maximum-scale=${scale},minimum-scale=${scale}`);\n这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。',
        ['https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1615998119364-e2b81466-ba5b-4eb8-af5f-61c5621bb0af.jpeg?x-oss-process=image%2Fresize%2Cw_1500']
      ]
    ],
    vueQuestion: [
      ['Vue的基本原理',
        '当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。',
        ['https://cdn.nlark.com/yuque/0/2021/png/1500604/1620128979608-f7465ffc-9411-43e3-a6bc-96ab44dd77df.png']
      ],
      ['双向数据绑定的原理',
        'Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\n1.需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n2.compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n3.Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\n4.MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果',
        ['https://cdn.nlark.com/yuque/0/2021/png/1500604/1618656573096-ebdc520c-5d60-4d12-ad04-5df4ebbb5fe7.png']
      ],
      ['MVVM、MVC、MVP的区别',
        'MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。\n在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。\n（1）MVC\nMVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。\n（2）MVVM\nMVVM 分为 Model、View、ViewModel：\nModel代表数据模型，数据和业务逻辑都在Model层中定义；\nView代表UI视图，负责数据的展示；\nViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；\n \nModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。 \n这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。\n（3）MVP\nMVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。',
        ['https://cdn.nlark.com/yuque/0/2020/png/1500604/1603814137582-5a9aa62f-0045-4272-bef0-447dedb25596.png',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1603814104939-8c8ac923-735d-4476-937a-cb1f795ffe84.png']
      ],
      ['Computed和Watch的区别',
        '对于Computed：\n它支持缓存，只有依赖的数据发生了变化，才会重新计算\n不支持异步，当Computed中有异步操作时，无法监听数据的变化\ncomputed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。\n如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed\n如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。\n \n对于Watch：\n它不支持缓存，数据变化时，它就会触发相应的操作\n支持异步监听\n监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值\n当一个属性发生变化时，就需要执行相应的操作\n监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：\nimmediate：组件加载立即触发回调函数\ndeep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。\n当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。\n     \n总结：\ncomputed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。\nwatch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。\n \n运用场景：\n当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。\n当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。'
      ],
      ['Computed 和 Methods 的区别',
        '可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的\n不同点：\ncomputed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；\nmethod 调用总会执行该函数。'
      ],
      ['v-if和v-show的区别',
        '手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；\n编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；\n性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。'
      ],
      ['data为什么是一个函数而不是对象',
        'JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。\n而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。\n所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。'
      ],
      ['Vue 单页应用与多页应用的区别',
        '概念：\nSPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。\nMPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。\n \n区别：',
        ['https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1609521413572-54d0bd0f-8ed6-4438-997a-c890e4cd9c5e.jpeg']
      ],
      ['对 React 和 Vue的理解，它们的异同',
        '相似之处：\n都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；\n都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；\n都使用了Virtual DOM（虚拟DOM）提高重绘性能；\n都有props的概念，允许组件间的数据传递；\n都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。\n \n不同之处 ：\n1）数据流\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n2）虚拟DOM\nVue2.x开始引入"Virtual DOM"，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。\nVue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。\n3）组件化\nReact与Vue最大的不同是模板的编写。\nVue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。\nReact推荐你所有的模板通用JavaScript的语法扩展——JSX书写。\n \n具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。\n4）监听数据变化的实现原理不同\nVue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\nReact 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。\n5）高阶组件\nreact可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。\n高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。\n6）构建工具\n两者都有自己的构建工具：\nReact ==> Create React APP\nVue ==> vue-cli\n7）跨平台\nReact ==> React Native\nVue ==> Weex'
      ],
      ['Vue的优点',
        '轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；\n简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；\n双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；\n组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；\n视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；\n虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；\n运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。'
      ],
      ['对SPA单页面的理解，它的优缺点分别是什么',
        'SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\n优点：\n用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n基于上面一点，SPA 相对对服务器压力小；\n前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\n \n缺点：\n初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\n前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\nSEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。'
      ],
      ['对虚拟DOM的理解',
        '从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。\n\n虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n \n另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。'
      ],
      ['DIFF算法的原理',
        '在新老虚拟DOM对比时：\n\n首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换\n如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\n比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。\n匹配时，找到相同的子节点，递归比较子节点\n \n在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。'
      ],
      ['简单说一下Vue的生命周期',
        'Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。\nbeforeCreate（创建前）：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。\ncreated**（创建后）** ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。\nbeforeMount（挂载前）：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。\nmounted（挂载后）：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。\nbeforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。\nupdated（更新后） ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\nbeforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。\ndestroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。\n \n另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。'
      ],
      ['组件通信的方式有哪些',
        '（1）父子组件间通信\n子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。\n通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。\n使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。\n（2）兄弟组件间通信\n使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。\n通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。\n（3）任意组件之间\n使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。\n \n如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。'
      ],
      ['路由的hash和history模式的区别',
        'Vue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。\n1. hash模式\n简介： hash模式是开发中默认的模式，它的URL带着一个#，例如：http://www.abc.com/#/vue，它的hash值就是#/vue。\n特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。\n原理： hash模式的主要原理就是onhashchange()事件：\nwindow.onhashchange = function(event){\n    console.log(event.oldURL, event.newURL);\n    let hash = location.hash.slice(1);\n}\n使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。\n2. history模式\n简介： history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。\n特点： 当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。\nAPI： history api可以分为两大部分，切换历史状态和修改历史状态：\n修改历史状态：包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。\n切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。\n虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。\n \n如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n})\n3. 两种模式对比\n调用 history.pushState() 相比于直接修改 hash，存在以下优势:\npushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；\npushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；\npushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；\npushState() 可额外设置 title 属性供后续使用。\nhash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。\n \nhash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。'
      ],
      ['对前端路由的理解',
        '在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。\n\n后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 SPA（单页面应用）。\n \nSPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：\nSPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。\n由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息\n \n为了解决这个问题，前端路由出现了。\n \n前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。\n \n那么如何实现这个目的呢？首先要解决两个问题：\n当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。\n单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？\n \n从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：\n拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。\n感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。'
      ],
      ['Vuex的原理以及自己的理解',
        'Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。\nVuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。\n（1）核心流程中的主要功能：\nVue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;\n在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;\n然后 Mutations 就去改变（Mutate）State 中的数据;\n当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。\n \n（2）各模块在核心流程中的主要功能：\nVue Components∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。\ndispatch∶操作行为触发方法，是唯一能执行action的方法。\nactions∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。\ncommit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。\nmutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。\nstate∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。\ngetters∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。',
        ['https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1609522434579-ff590978-32e1-4cf5-bbbd-d8caf932f8d6.jpeg']
      ],
      ['Vuex中action和mutation的区别',
        'mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      state.count++      // 变更状态\n    }\n  }\n})\n当触发一个类型为 increment 的 mutation 时，需要调用此函数：\nstore.commit(\'increment\')\n而Action类似于mutation，不同点在于：\nAction 可以包含任意异步操作。\nAction 提交的是 mutation，而不是直接变更状态。\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit(\'increment\')\n    }\n  }\n})\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。\n所以，两者的不同点如下：\nMutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。\nMutation：必须同步执行；Action：可以异步，但不能直接操作State。\n在视图更新时，先触发actions，actions再触发mutation\nmutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters'
      ],
      ['Redux和Vuex有什么区别。它们的共同思想',
        '（1）Redux 和 Vuex区别\n\nVuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可\nVuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可\nVuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）\n \n通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;\n \n（2）共同思想\n单—的数据源\n变化可以预测\n \n本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;\n形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;'
      ],
      ['Vue 3.0',
        '（1）监测机制的改变\n\n3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。\n消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：\n \n（2）只能监测属性，不能监测对象\n检测属性的添加和删除；\n检测数组索引和长度的变更；\n支持 Map、Set、WeakMap 和 WeakSet。\n \n（3）模板\n作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。\n同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。\n \n（4）对象式的组件声明方式\nvue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。\n3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易\n \n（5）其它方面的更改\n支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。\n支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。\n基于 tree shaking 优化，提供了更多的内置功能。'
      ],
      ['defineProperty和proxy的区别',
        'Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。这样当追踪数据发生变化时，setter 会被自动调用。\n\nObject.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。\n \n但是这样做有以下问题：\n添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。\n无法监控到数组下标和长度的变化。\n \nVue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，其有以下特点：\nProxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。'
      ]
    ],
    netQuestion: [
      [
        'GET和POST的请求的区别',
        'Post 和 Get 是 HTTP 请求的两种方法，其区别如下：- \n\n应用场景：GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。\n\n是否缓存：因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。\n\n发送的报文格式：**Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。\n\n安全性：**Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。\n\n请求长度：浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。\n\n参数类型：post 的参数传递支持更多的数据类型。'
      ],
      [
        '常见的HTTP请求方法',
        'GET: 向服务器获取数据；\n\n POST：将实体提交到指定的资源，通常会造成服务器资源的修改；\n\n PUT：上传文件，更新数据；\n\n DELETE：删除服务器上的对象；\n\n HEAD：获取报文首部，与GET相比，不返回报文主体部分；\n\n OPTIONS：询问支持的请求方法，用来跨域请求；\n\n CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；\n\n TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。'
      ],
      [
        'HTTP 1.0 和 HTTP 1.1 之间有哪些区别？',
        'HTTP 1.0和 HTTP 1.1 有以下区别：\n\n连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。\n\n资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、IfNone-Match 等更多可供选择的缓存头来控制缓存策略。\n\nhttp1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。\n\nhttp1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。'
      ],
      [
        'HTTP和HTTPS协议的区别',
        'HTTP和HTTPS协议的主要区别如下：\n\nHTTPS协议需要CA证书，费用较高；而HTTP协议不需要；\n\nHTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；\n\n使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；\n\nHTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。'
      ],
      [
        '当在浏览器中输入 Google.com 并且按下回车之后发生了什么？',
        '（1）解析URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。\n\n（2）缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。\n\n（3）DNS解析：下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。\n\n（4）获取MAC地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。\n\n（5）TCP三次握手：下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。\n\n（6）HTTPS握手：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。\n\n（7）返回数据：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。\n\n（8）页面渲染：浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。\n\n（9）TCP四次挥手：最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。'
      ],
      [
        'HTTP请求报文的是什么样的？',
        '请求报⽂有4部分组成:\n\n请求⾏\n\n请求头部\n\n空⾏\n\n请求体\n\n其中：\n\n（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET/index.html HTTP/1.1。\n\n（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔\n\nUser-Agent：产⽣请求的浏览器类型。\n\nAccept：客户端可识别的内容类型列表。\n\nHost：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。\n\n（3）请求体: post put等请求携带的数据',
        [
          'https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907508156-a82d09e4-00bf-4dc7-a3a3-1ae75481754e.png',
          'https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907573585-6651540d-9dee-4b33-a97f-dee1b31f231c.png'
        ]
      ],
      [
        'HTTP响应报文的是什么样的？',
        '请求报⽂有4部分组成:\n\n响应⾏\n\n响应头\n\n空⾏\n\n响应体\n\n响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。\n\n响应头：响应部⾸组成\n\n响应体：服务器响应的数据',
        ['https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907658281-b3a51c98-db27-45be-9b0c-fb2c7665b015.png']
      ],
      [
        '什么是HTTPS协议？',
        '超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\n\nHTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。\n\n安全层的主要职责就是对发起的HTTP请求的数据进行加密操作 和 对接收到的HTTP的内容进行解密操作。',
        ['https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png?x-oss-process=image%2Fresize%2Cw_1500']
      ],
      [
        'TLS/SSL的工作原理',
        'TLS/SSL全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。\n\nTLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：\n\n基于散列函数验证信息的完整性\n\n对称加密算法采用协商的秘钥对数据加密\n\n非对称加密实现身份认证和秘钥协商\n\n1）散列函数hash常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。\n\n特点：在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。\n\n2）对称加密对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。\n\n常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。\n\n特点：对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。\n\n3）非对称加密非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。\n\n常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。\n\n特点：非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。\n\n综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。',
        ['https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png']
      ],
      [
        'HTTPS是如何保证安全的？',
        '先理解两个概念：\n\n对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。\n\n⾮对称加密：\n\n. 私钥 + 公钥= 密钥对\n\n. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密\n\n. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅\n\n. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密\n\n⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。\n\n解决⽅案：\n\n结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。\n\n此时⼜带来⼀个问题，中间⼈问题：\n\n如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。 \n\n所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。 \n\n但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。\n\n数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。'
      ],
      [
        'HTTP状态码',
        '状态码的类别：\n类别	原因	描述\n1xx	Informational(信息性状态码)	接受的请求正在处理\n2xx	Success(成功状态码)	请求正常处理完毕\n3xx	Redirection(重定向状态码)	需要进行附加操作一完成请求\n4xx	Client Error (客户端错误状态码)	服务器无法处理请求\n5xx	Server Error(服务器错误状态码)	服务器处理请求出错\n\n（1）2XX 成功\n200 OK，表示从客户端发来的请求在服务器端被正确处理\n204 No content，表示请求成功，但响应报文不含实体的主体部分\n205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容\n206 Partial Content，进行范围请求\n\n（2）3XX 重定向    \n301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n302 found，临时性重定向，表示资源临时被分配了新的 URL\n303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源\n304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求\n\n（3）4XX 客户端错误       \n400 bad request，请求报文存在语法错误\n401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n403 forbidden，表示对请求资源的访问被服务器拒绝\n404 not found，表示在服务器上没有找到请求的资源\n\n（4）5XX 服务器错误\n500 internal sever error，表示服务器端在执行请求时发生了错误\n501 Not Implemented，表示服务器不支持当前请求所需要的某个功能\n503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求'
      ],
      [
        ' DNS 协议是什么',
        '概念： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。\n\n作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。'
      ],
      [
        'DNS完整的查询过程',
        'DNS服务器解析域名的过程：\n\n首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步\n\n将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步\n\n本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址\n\n本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址\n\n本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果\n\n本地DNS服务器将返回结果保存在缓存中，便于下次使用\n\n本地DNS服务器将返回结果返回给浏览器\n\n比如要查询 www.baidu.com 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。'
      ],
      [
        ' OSI七层模型',
        'ISO为了更好的使网络应用更为普及，推出了OSI参考模型。\n\n（1）应用层\nOSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。\n\n在客户端与服务器中经常会有数据的请求，这个时候就是会用到http(hyper text transfer protocol)(超文本传输协议)或者https.在后端设计数据接口时，我们常常使用到这个协议。\nFTP是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。\nSMTP是simple mail transfer protocol（简单邮件传输协议）。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。\n（2）表示层\n表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。\n     \n在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。\n\n（3）会话层\n会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。\n\n（4）传输层\n传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。\n\n（5）网络层\n本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。\n\n（6）数据链路层\n将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。\n\n网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。\n\n（7）物理层\n实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。\n\nOSI七层模型通信特点：对等通信\n\n对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。',
        ['https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604024701811-7ac177bc-d649-45b8-8646-53af8f18a0de.webp']
      ],
      [
        'TCP/IP五层协议',
        'TCP/IP五层协议和OSI的七层协议对应关系如下：\n\n应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。\n\n传输层 (transport layer)：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：\n\n传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；\n用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。\n网络层 (internet layer)：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。\n\n数据链路层 (data link layer)：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。\n\n物理层 (physical Layer)：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。\n\n从上图中可以看出，TCP/IP模型比OSI模型更加简洁，它把应用层/表示层/会话层全部整合为了应用层。\n\n在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。图2\n\n在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议： 图3\n\n同样，TCP/IP五层协议的通信方式也是对等通信：图4',
        [
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png',
          'https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604025001463-47398363-0ab1-4bcf-b247-5d3d76ce117a.webp',
          'https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604025001203-7b104c36-1453-475e-a282-ff2e9cb19e2c.webp',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1604065635582-1a4e62ba-bdfa-45db-8a56-0302ff9a8020.png'
        ]
      ],
      [
        'TCP 和 UDP的概念及特点',
        'TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：\n（1）UDP\n\nUDP的全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。\n \n它的特点如下：\n\n1）面向无连接\n\n首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\n\n具体来说就是：\n\n在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了\n在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作\n2）有单播，多播，广播的功能\n\nUDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。\n\n3）面向报文\n\n发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文\n\n4）不可靠性\n\n首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。\n\n并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。\n\n再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。\n\n5）头部开销小，传输数据报文时是很高效的。\n\nUDP 头部包含了以下几个数据：\n\n两个十六位的端口号，分别为源端口（可选字段）和目标端口\n整个数据报文的长度\n整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误\n \n\n因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很\n\n\n（2）TCP\n\nTCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据\n\n它有以下几个特点：\n\n1）面向连接\n\n面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。\n\n2）仅支持单播传输\n\n每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。\n\n3）面向字节流\n\nTCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。\n\n4）可靠传输\n\n对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。\n\n5）提供拥塞控制\n\n当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。\n\n6）提供全双工通信\n\nTCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）',
        'https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023358917-72134998-53bd-4d9c-b71f-7a762dff31a9.png'
      ],
      [
        ' TCP和UDP的区别',
        '	UDP	TCP\n是否连接	无连接	面向连接\n是否可靠	不可靠传输，不使用流量控制和拥塞控制	可靠传输（数据顺序和正确性），使用流量控制和拥塞控制\n连接对象个数	支持一对一，一对多，多对一和多对多交互通信	只能是一对一通信\n传输方式	面向报文	面向字节流\n首部开销	首部开销小，仅8字节	首部最小20字节，最大60字节\n适用场景	适用于实时应用，例如视频会议、直播	适用于要求可靠传输的应用，例如文件传输'
      ],
      [
        'TCP和UDP的使用场景',
        'TCP应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。\n\nUDP应用场景： 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。'
      ],
      [
        'TCP的三次握手和四次挥手',
        '三次握手\n\n三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。\n\n简单来说就是以下三步：\n\n第一次握手：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。\n第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。\n第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。\n \n\nTCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。\n\n（2）四次挥手\n \n简单来说就是以下四步：\n\n第一次**挥手：**若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。\n第二次**挥手**：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。\n第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。\n第四次**挥手：**客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。\n \n\nTCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。\n\n最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。',
        ['https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663256-5eb6dcdf-fdb6-4b67-a3da-da15c1d396fb.png',
          'https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663279-0ea063ba-a06b-4f57-9aa9-0e2d1c8d373c.png']
      ],
    ],
    browserQuestion: [
      ['什么是 XSS 攻击？',
        '（1）概念\nXSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。\n \nXSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。\n \n攻击者可以通过这种攻击方式可以进行以下操作：\n获取页面的数据，如DOM、cookie、localStorage；\nDOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；\n破坏页面结构；\n流量劫持（将链接指向某网站）；\n（2）攻击类型\nXSS 可以分为存储型、反射型和 DOM 型：\n存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。\n反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。\nDOM 型指的通过修改页面的 DOM 节点形成的 XSS。\n \n1）存储型 XSS 的攻击步骤：\n攻击者将恶意代码提交到⽬标⽹站的数据库中。\n⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。\n⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n \n这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。\n \n2）反射型 XSS 的攻击步骤：\n攻击者构造出特殊的 URL，其中包含恶意代码。\n⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。\n⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n \n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。\n \n反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。\n \n3）DOM 型 XSS 的攻击步骤：\n攻击者构造出特殊的 URL，其中包含恶意代码。\n⽤户打开带有恶意代码的 URL。\n⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。\n恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n \nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。'
      ],
      ['如何防御 XSS 攻击？',
        '可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：\n可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。\n使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。\nCSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。\n通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式\n对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。'
      ],
      ['什么是 CSRF 攻击？',
        '（1）概念\nCSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。\n \nCSRF 攻击的本质是**利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。**\n（2）攻击类型\n常见的 CSRF 攻击有三种：\nGET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。\nPOST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。\n链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。'
      ],
      ['如何防御 CSRF 攻击？',
        'CSRF 攻击可以使用以下方法来防护：\n进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）\n使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。\n对 Cookie 进行**双重验证**，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。\n在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。'
      ],
      ['进程和线程的区别',
        '进程可以看做独立应用，线程不能\n资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。\n通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。\n调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。'
      ],
      ['进程之前的通信方式---了解即可',
        '（1）管道通信\n管道是一种最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。\n \n管道的特点：\n只能单向通信\n只能血缘关系的进程进行通信\n依赖于文件系统\n生命周期随进程\n面向字节流的服务\n管道内部提供了同步机制\n（2）消息队列通信\n消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。\n \n使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。\n（3）信号量通信\n共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。\n（4）信号通信\n信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。\n（5）共享内存通信\n共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。\n（6）套接字通信\n上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。'
      ],
      ['死锁产生的原因？ 如果解决死锁的问题？---了解即可',
        '所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。\n系统中的资源可以分为两类：\n可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；\n不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。\n \n产生死锁的原因：\n（1）竞争资源\n产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）\n产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁\n（2）进程间推进顺序非法\n若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁\n \n产生死锁的必要条件：\n互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。\n请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。\n不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。\n环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。\n \n预防死锁的方法：\n资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）\n只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）\n可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）\n资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）'
      ],
      [' 对浏览器的缓存机制的理解',
        '浏览器缓存的全过程：\n浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；\n下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；\n如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；\n服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；\n如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；\n业务流程图1.png\n很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。',
        ['https://cdn.nlark.com/yuque/0/2021/png/1500604/1618399660902-60a33dae-cedc-4bd0-9a5b-160c5da3f516.png']
      ],
      ['协商缓存和强缓存的区别',
        '（1）强缓存\n使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\n \n强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。\n \n（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。\n（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，\n \nCache-Control可设置的字段：\npublic：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；\nprivate：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；\nno-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；\nno-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；\nmax-age=：设置缓存的最大有效期，单位为秒；\ns-maxage=：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；\nmax-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。\n \n一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。\n \nno-cache和no-store很容易混淆：\nno-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；\nno-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。\n（2）协商缓存\n如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。\n \n上面已经说到了，命中协商缓存的条件有两个：\nmax-age=xxx 过期了\n值为no-cache\n \n使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。\n \n协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。\n（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。\n（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。\n \n当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。\n \n总结：\n强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。'
      ],
      ['常见浏览器所用内核---了解即可',
        '（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；\n（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；\n（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；\n（4） Safari 浏览器内核：Webkit 内核；\n（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；\n（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；\n（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；\n（8） 百度浏览器、世界之窗内核：IE 内核；\n（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；\n（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。'
      ],
      ['浏览器的渲染过程',
        '浏览器渲染主要有以下步骤：\n首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。\n然后对 CSS 进行解析，生成 CSSOM 规则树。\n根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。\n当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。\n布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。\n大致过程如图所示：\nimage\n注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。',
        ['https://cdn.nlark.com/yuque/0/2020/png/1500604/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png']
      ],
      ['浏览器渲染优化',
        '（1）针对JavaScript：JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：\n（1）尽量将JavaScript文件放在body的最后\n（2） body中间尽量不要写<script>标签\n（3）<script>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：\nscript 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；\nasync 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；\ndefer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。\n \n（2）针对CSS：使用CSS有三种方式：使用link、@import、内联样式，其中link和@import都是导入外部样式。它们之间的区别：\nlink：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码\n@import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)\nstyle：GUI直接渲染\n \n外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。\n \n所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。\n \n（3）针对DOM树、CSSOM树：\n可以通过以下几种方式来减少渲染的时间：\nHTML文件的代码层级尽量不要太深\n使用语义化的标签，来避免不标准语义化的特殊处理\n减少CSSD代码的层级，因为选择器是从左向右进行解析的\n \n（4）减少回流与重绘：\n操作DOM时，尽量在低层级的DOM节点进行操作\n不要使用table布局， 一个小的改动可能会使整个table进行重新布局\n使用CSS的表达式\n不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。\n使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素\n避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中\n将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\n将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。\n \n浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列\n \n浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n \n将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。'
      ],
      ['浏览器本地存储方式及使用场景',
        '（1）Cookie\nCookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。\n \nCookie的特性：\nCookie一旦创建成功，名称就无法修改\nCookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie\n每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb\n有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的\nCookie在请求一个新的页面的时候都会被发送过去\n \n如果需要域名之间跨域共享Cookie，有两种方法：\n使用Nginx反向代理\n在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId\n \nCookie的使用场景：\n最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。\n可以用来统计页面的点击次数\n（2）LocalStorage\nLocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。\n \nLocalStorage的优点：\n在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息\nLocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在\n仅储存在本地，不像Cookie那样每次HTTP请求都会被携带\n \nLocalStorage的缺点：\n存在浏览器兼容问题，IE8以下版本的浏览器不支持\n如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage\nLocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问\n \nLocalStorage的**常用API：**\n// 保存数据到 localStorage\nlocalStorage.setItem(\'key\', \'value\');\n// 从 localStorage 获取数据\nlet data = localStorage.getItem(\'key\');\n// 从 localStorage 删除保存的数据\nlocalStorage.removeItem(\'key\');\n// 从 localStorage 删除所有保存的数据\nlocalStorage.clear();\n// 获取某个索引的Key\nlocalStorage.key(index)\nLocalStorage的**使用场景：**\n有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可\n在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中\n（3）SessionStorage\nSessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。\n \nSessionStorage**与LocalStorage对比：**\nSessionStorage和LocalStorage都在本地进行数据存储；\nSessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage只有在同一浏览器的同一窗口下才能够共享；\nLocalStorage和SessionStorage都不能被爬虫爬取；\n \nSessionStorage的**常用API：**\n// 保存数据到 sessionStorage\nsessionStorage.setItem(\'key\', \'value\');\n// 从 sessionStorage 获取数据\nlet data = sessionStorage.getItem(\'key\');\n// 从 sessionStorage 删除保存的数据\nsessionStorage.removeItem(\'key\');\n// 从 sessionStorage 删除所有保存的数据\nsessionStorage.clear();\n// 获取某个索引的Key\nsessionStorage.key(index)\nSessionStorage的**使用场景**\n由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。'
      ],
      ['Cookie、LocalStorage、SessionStorage区别',
        '浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。\ncookie：其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。\nsessionStorage：html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。\nlocalStorage：html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。\n \n上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。'
      ],
      ['前端储存的⽅式有哪些？',
        'cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；\nlocalStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；\nsessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；\nWeb SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；\nIndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。'
      ],
      ['什么是同源策略',
        '跨域问题其实就是浏览器的同源策略造成的。\n同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。\n \n下表给出了与 URL http://store.company.com/dir/page.html 的源进行对比的示例:\nURL	是否跨域	原因\nhttp://store.company.com/dir/page.html	同源	完全相同\nhttp://store.company.com/dir/inner/another.html	同源	只有路径不同\nhttps://store.company.com/secure.html	跨域	协议不同\nhttp://store.company.com:81/dir/etc.html	跨域	端口不同 ( http:// 默认端口是80)\nhttp://news.company.com/dir/other.html	跨域	主机不同\n同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。\n \n同源政策主要限制了三个方面：\n当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。\n当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。\n当前域下 ajax 无法发送跨域请求。\n \n同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。'
      ],
      ['如何解决跨越问题',
        '（1）CORS下面是MDN对于CORS的定义：跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现CORS的关键就是服务器，只要服务器实现了CORS请求，就可以跨源通信了。 浏览器将CORS分为简单请求和非简单请求： 简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：1）请求方法是以下三种方法之一：HEADGETPOST2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain若不满足以上条件，就属于非简单请求了。 （1）简单请求过程：对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：Access-Control-Allow-Origin: http://api.bob.com  // 和Orign一直Access-Control-Allow-Credentials: true   // 表示是否允许发送CookieAccess-Control-Expose-Headers: FooBar   // 指定返回其他字段的值Content-Type: text/html; charset=utf-8   // 表示文档类型如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。 在简单请求中，在服务器内，至少需要设置字段：**Access-Control-Allow-Origin** （2）非简单请求过程非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为预检请求。 浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。 预检请求使用的请求方法是OPTIONS，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。Access-Control-Request-Headers： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。 服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。 服务器回应的CORS的字段如下：Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段Access-Control-Allow-Credentials: true   // 表示是否允许发送CookieAccess-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 在非简单请求中，至少需要设置以下字段：\'Access-Control-Allow-Origin\'  \'Access-Control-Allow-Methods\'\'Access-Control-Allow-Headers\'减少OPTIONS请求次数：OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。CORS中Cookie相关问题：在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：在请求中设置 **withCredentials** 默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.// 原生 xml 的设置方式var xhr = new XMLHttpRequest();xhr.withCredentials = true;// axios 设置方式axios.defaults.withCredentials = true;Access-Control-Allow-Credentials 设置为 trueAccess-Control-Allow-Origin 设置为非 *****（2）JSONPjsonp的原理就是利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。1）原生JS实现：<script>    var script = document.createElement(\'script\');    script.type = \'text/javascript\';    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数    script.src = \'http://www.domain2.com:8080/login?user=admin&callback=handleCallback\';    document.head.appendChild(script);    // 回调执行函数    function handleCallback(res) {        alert(JSON.stringify(res));    } </script>服务端返回如下（返回时即执行全局函数）：handleCallback({"success": true, "user": "admin"})2）Vue axios实现：this.$http = axios;this.$http.jsonp(\'http://www.domain2.com:8080/login\', {    params: {},    jsonp: \'handleCallback\'}).then((res) => {    console.log(res); })后端node.js代码：var querystring = require(\'querystring\');var http = require(\'http\');var server = http.createServer();server.on(\'request\', function(req, res) {    var params = querystring.parse(req.url.split(\'?\')[1]);    var fn = params.callback;    // jsonp返回设置    res.writeHead(200, { \'Content-Type\': \'text/javascript\' });    res.write(fn + \'(\' + JSON.stringify(params) + \')\');    res.end();});server.listen(\'8080\');console.log(\'Server is running at port 8080...\');JSONP的缺点：具有局限性， 仅支持get方法不安全，可能会遭受XSS攻击（3）postMessage 跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：页面和其打开的新窗口的数据传递多窗口之间消息传递页面与嵌套的iframe消息传递上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数：data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。 1）a.html：(domain1.com/a.html)<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe><script>           var iframe = document.getElementById(\'iframe\');    iframe.onload = function() {        var data = {            name: \'aym\'        };        // 向domain2传送跨域数据        iframe.contentWindow.postMessage(JSON.stringify(data), \'http://www.domain2.com\');    };    // 接受domain2返回数据    window.addEventListener(\'message\', function(e) {        alert(\'data from domain2 ---> \' + e.data);    }, false);</script>2）b.html：(domain2.com/b.html)<script>    // 接收domain1的数据    window.addEventListener(\'message\', function(e) {        alert(\'data from domain1 ---> \' + e.data);        var data = JSON.parse(e.data);        if (data) {            data.number = 16;            // 处理后再发回domain1            window.parent.postMessage(JSON.stringify(data), \'http://www.domain1.com\');        }    }, false);</script><script>    // 接收domain1的数据    window.addEventListener(\'message\', function(e) {        alert(\'data from domain1 ---> \' + e.data);        var data = JSON.parse(e.data);        if (data) {            data.number = 16;            // 处理后再发回domain1            window.parent.postMessage(JSON.stringify(data), \'http://www.domain1.com\');        }    }, false);</script>（4）nginx代理跨域nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。 1）nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。location / {  add_header Access-Control-Allow-Origin *;}2）nginx反向代理接口跨域跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。 nginx具体配置：#proxy服务器server {    listen       81;    server_name  www.domain1.com;    location / {        proxy_pass   http://www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    }}（5）nodejs 中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 1）非vue框架的跨域使用node + express + http-proxy-middleware搭建一个proxy服务器。前端代码：var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open(\'get\', \'http://www.domain1.com:3000/login?user=admin\', true);xhr.send();中间件服务器代码：var express = require(\'express\');var proxy = require(\'http-proxy-middleware\');var app = express();app.use(\'/\', proxy({    // 代理跨域目标接口    target: \'http://www.domain2.com:8080\',    changeOrigin: true,    // 修改响应头信息，实现跨域并允许带cookie    onProxyRes: function(proxyRes, req, res) {        res.header(\'Access-Control-Allow-Origin\', \'http://www.domain1.com\');        res.header(\'Access-Control-Allow-Credentials\', \'true\');    },    // 修改响应信息中的cookie域名    cookieDomainRewrite: \'www.domain1.com\'  // 可以为false，表示不修改}));app.listen(3000);console.log(\'Proxy server is listen at port 3000...\');2）vue框架的跨域node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。 webpack.config.js部分配置：module.exports = {    entry: {},    module: {},    ...    devServer: {        historyApiFallback: true,        proxy: [{            context: \'/login\',            target: \'http://www.domain2.com:8080\',  // 代理跨域目标接口            changeOrigin: true,            secure: false,  // 当代理某些https服务报错时用            cookieDomainRewrite: \'www.domain1.com\'  // 可以为false，表示不修改        }],        noInfo: true    }}（6）document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。1）父窗口：(domain.com/a.html)<iframe id="iframe" src="http://child.domain.com/b.html"></iframe><script>    document.domain = \'domain.com\';    var user = \'admin\';</script>1）子窗口：(child.domain.com/a.html)<script>    document.domain = \'domain.com\';    // 获取父窗口中变量    console.log(\'get js data from parent ---> \' + window.parent.user);</script>（7）location.hash + iframe跨域实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1）a.html：(domain1.com/a.html)<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe><script>    var iframe = document.getElementById(\'iframe\');    // 向b.html传hash值    setTimeout(function() {        iframe.src = iframe.src + \'#user=admin\';    }, 1000);        // 开放给同域c.html的回调方法    function onCallback(res) {        alert(\'data from c.html ---> \' + res);    }</script>2）b.html：(.domain2.com/b.html)<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe><script>    var iframe = document.getElementById(\'iframe\');    // 监听a.html传来的hash值，再传给c.html    window.onhashchange = function () {        iframe.src = iframe.src + location.hash;    };</script>3）c.html：(http://www.domain1.com/c.html)<script>    // 监听b.html传来的hash值    window.onhashchange = function () {        // 再通过操作同域a.html的js回调，将结果传回        window.parent.parent.onCallback(\'hello: \' + location.hash.replace(\'#user=\', \'\'));    };</script>（8）window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1）a.html：(domain1.com/a.html)var proxy = function(url, callback) {    var state = 0;    var iframe = document.createElement(\'iframe\');    // 加载跨域页面    iframe.src = url;    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name    iframe.onload = function() {        if (state === 1) {            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据            callback(iframe.contentWindow.name);            destoryFrame();        } else if (state === 0) {            // 第1次onload(跨域页)成功后，切换到同域代理页面            iframe.contentWindow.location = \'http://www.domain1.com/proxy.html\';            state = 1;        }    };    document.body.appendChild(iframe);    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）    function destoryFrame() {        iframe.contentWindow.document.write(\'\');        iframe.contentWindow.close();        document.body.removeChild(iframe);    }};// 请求跨域b页面数据proxy(\'http://www.domain2.com/b.html\', function(data){    alert(data);});2）proxy.html：(domain1.com/proxy.html) 中间代理页，与a.html同域，内容为空即可。3）b.html：(domain2.com/b.html)<script>    window.name = \'This is domain2 data!\';</script>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。（9）WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1）前端代码：<div>user input：<input type="text"></div><script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script><script>var socket = io(\'http://www.domain2.com:8080\');// 连接成功处理socket.on(\'connect\', function() {    // 监听服务端消息    socket.on(\'message\', function(msg) {        console.log(\'data from server: ---> \' + msg);     });    // 监听服务端关闭    socket.on(\'disconnect\', function() {         console.log(\'Server socket has closed.\');     });});document.getElementsByTagName(\'input\')[0].onblur = function() {    socket.send(this.value);};</script>2）Nodejs socket后台：var http = require(\'http\');var socket = require(\'socket.io\');// 启http服务var server = http.createServer(function(req, res) {    res.writeHead(200, {        \'Content-type\': \'text/html\'    });    res.end();});server.listen(\'8080\');console.log(\'Server is running at port 8080...\');// 监听socket连接socket.listen(server).on(\'connection\', function(client) {    // 接收信息    client.on(\'message\', function(msg) {        client.send(\'hello：\' + msg);        console.log(\'data from client: ---> \' + msg);    });    // 断开处理    client.on(\'disconnect\', function() {        console.log(\'Client socket has closed.\');     });});'
      ],
      ['事件是什么？事件模型？',
        '事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。\n事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：\nDOM0 级事件模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这方式。直接在dom对象上注册事件名称，就是DOM0写法。\nIE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\nDOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。'
      ], 
      ['对事件委托的理解',
        '（1）事件委托的概念\n事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。\n \n使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。\n（2）事件委托的特点\n减少内存消耗\n如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：\n<ul id="list">\n  <li>item 1</li>\n  <li>item 2</li>\n  <li>item 3</li>\n  ......\n  <li>item n</li>\n</ul>\n如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。\n动态绑定事件\n给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。\n// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：\n// 给父层元素绑定事件\ndocument.getElementById(\'list\').addEventListener(\'click\', function (e) {\n  // 兼容性处理\n  var event = e || window.event;\n  var target = event.target || event.srcElement;\n  // 判断是否匹配目标元素\n  if (target.nodeName.toLocaleLowerCase === \'li\') {\n    console.log(\'the content is: \', target.innerHTML);\n  }\n});\n在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；\n（3）局限性\n当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。\n \n当然事件委托不是只有优点，它也是有缺点的，事件委托会影响页面性能，主要影响因素有：\n元素中，绑定事件委托的次数；\n点击的最底层元素，到绑定事件元素之间的DOM层数；\n \n在必须使用事件委托的地方，可以进行如下的处理：\n只在必须的地方，使用事件委托，比如：ajax的局部刷新区域\n尽量的减少绑定的层级，不在body元素上，进行绑定\n减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。'
      ],
      ['事件委托的使用场景',
        '场景：给页面的所有的a标签添加click事件，代码如下：\ndocument.addEventListener("click", function(e) {\n    if (e.target.nodeName == "A")\n        console.log("a");\n}, false);\n但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。\n \n这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：\ndocument.addEventListener("click", function(e) {\n    var node = e.target;\n    while (node.parentNode.nodeName != "BODY") {\n        if (node.nodeName == "A") {\n            console.log("a");\n            break;\n        }\n        node = node.parentNode;\n    }\n}, false);'
      ],
      ['对事件循环的理解',
        '因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。\nimage\nEvent Loop 执行顺序如下所示：\n首先执行同步代码，这属于宏任务\n当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行\n执行所有微任务\n当执行完所有微任务后，如有必要会渲染页面\n然后开始下一轮 Event Loop，执行宏任务中的异步代码',
        ['https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476500217-472563e1-de67-403f-baa7-0fd574d0e618.png?x-oss-process=image%2Fresize%2Cw_1500']
      ],
      ['宏任务和微任务分别有哪些',
        '微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。\n宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。'
      ],
      ['Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？',
        'Node 中的 Event Loop 和浏览器中的是完全不相同的东西。\nNode 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。\nimage\n（1）Timers（计时器阶段）：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。\n（2）Pending callbacks：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。\n（3）Idle/Prepare：仅供内部使用。\n（4）Poll（轮询阶段）：\n当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。\n当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。\n（5）Check（查询阶段）：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。\n（6）Close callbacks：执行一些关闭回调，比如socket.on(\'close\', ...)等。\n \n下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是随机的\nsetTimeout(() => {\n    console.log(\'setTimeout\')\n}, 0)\nsetImmediate(() => {\n    console.log(\'setImmediate\')\n})\n对于以上代码来说，setTimeout 可能执行在前，也可能执行在后\n首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的\n进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调\n那么如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了\n当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：\nconst fs = require(\'fs\')\nfs.readFile(__filename, () => {\n    setTimeout(() => {\n        console.log(\'timeout\');\n    }, 0)\n    setImmediate(() => {\n        console.log(\'immediate\')\n    })\n})\n在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。\n \n上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask\nimage\nsetTimeout(() => {\n  console.log(\'timer21\')\n}, 0)\nPromise.resolve().then(function() {\n  console.log(\'promise1\')\n})\n对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。\n \n最后来看 Node 中的 process.nextTick，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。\nsetTimeout(() => {\n console.log(\'timer1\')\n Promise.resolve().then(function() {\n   console.log(\'promise1\')\n })\n}, 0)\nprocess.nextTick(() => {\n console.log(\'nextTick\')\n process.nextTick(() => {\n   console.log(\'nextTick\')\n   process.nextTick(() => {\n     console.log(\'nextTick\')\n     process.nextTick(() => {\n       console.log(\'nextTick\')\n     })\n   })\n })\n})\n对于以上代码，永远都是先把 nextTick 全部打印出来。',
        ['https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476641904-a9763034-9114-4a7c-aa50-1bdb612f2f5e.png',
      'https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476641927-75409d91-38a1-4797-aa75-cb02dd95d732.png'
    ]
      ],
      ['V8的垃圾回收机制是怎样的',
        'V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。\n（1）新生代算法\n新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。\n \n在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。\n \n（2）老生代算法\n老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。\n \n先来说下什么情况下对象会出现在老生代空间中：\n新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。\nTo 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。\n \n老生代中的空间很复杂，有如下几个空间\nenum AllocationSpace {\n  // TODO(v8:7464): Actually map this space\'s memory as read-only.\n  RO_SPACE,    // 不变的对象空间\n  NEW_SPACE,   // 新生代用于 GC 复制算法的空间\n  OLD_SPACE,   // 老生代常驻对象空间\n  CODE_SPACE,  // 老生代代码对象空间\n  MAP_SPACE,   // 老生代 map 对象\n  LO_SPACE,    // 老生代大空间对象\n  NEW_LO_SPACE,  // 新生代大空间对象\n  FIRST_SPACE = RO_SPACE,\n  LAST_SPACE = NEW_LO_SPACE,\n  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,\n  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE\n};\n在老生代中，以下情况会先启动标记清除算法：\n某一个空间没有分块的时候\n空间中被对象超过一定限制\n空间不能保证新生代中的对象移动到老生代中\n \n在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。\n \n清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。'
      ]
    ]
  },
  onclick: function (e) {
    const that = this
    console.log(e.target.dataset.que);
    const x = 0, y = that.data[`${e.target.dataset.que}`].length - 1;
    const que = that.data[`${e.target.dataset.que}`][Math.floor(Math.random() * (y - x + 1)) + x]
    that.setData({
      quest: que[0],
      answer: que[1],
      status: true,
      imgurl: que[2]
    })
  },
  showAnswer: function () {
    this.setData({
      status: false
    })
  },
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {

  }
})